C++20 driver to use the digital thermometer [[https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf][ds18b20]] with AVR. The strong points of this work are the usage of [[#resumable-functions][coroutines]] to read the temperature and the [[#policies][compile-time operations to optimize the code size]].

/Note: if you're willing to use this library, be aware that it is a work under heavily development/

** Simple [async]
This example illustrates the reading of the temperature using the asynchronous approach. It's considered that there is only one device using the bus, it has the default resolution of 12 bits, and there is only interest in reading the whole part of the temperature value.
#+BEGIN_SRC C++
#include <ds18b20.hpp>

void do_something(uint8_t temp){}

int main() {
    ds18b20::sensor<PB3> thermo;

    while(true)
        if(auto temp = thermo.read()) {
            if(temp.has_value())
                do_something(temp.value());
        }
}
#+END_SRC
~326 bytes~ of code size compiled with ~avr-gcc 10.2.0~ and ~-Os -mmcu=attiny85~.

~read()~ is a coroutine that returns a lazy temperature value(~temp~) which has a ~done()~ method that returns ~false~ if the coroutine is running and ~true~ is it is completed. 

** Simple [sync]
If the asynchronous approach is not desirable, the temperature value can be obtained through a synchronous read operation(~sync_read()~). The caller blocks until the temperature value or an error are available.
#+BEGIN_SRC C++
#include <ds18b20.hpp>

void do_something(uint8_t temp){}

int main() {
    ds18b20::sensor<PB3> thermo;

    while(true)
        if(auto temp = sync_read(thermo))
            do_something(temp.value());
}
#+END_SRC
~364 bytes~ of code size compiled with ~avr-gcc 10.2.0~ and ~-Os -mmcu=attiny85~.

** Multiple devices
#+BEGIN_SRC C++
#include <ds18b20.hpp>

void do_something_inside(uint8_t temp){}
void do_something_outside(uint8_t temp){}

int main() {
    using namespace ds18b20;

    sensor<PB3, Rom<40, 251, 43, 31, 5, 0, 0, 139>> inside;
    sensor<PB3, Rom<40, 198, 8, 141, 5, 0, 0, 124>> outside;

    while(true) {
        if(auto temp = inside.read())
            if(temp.has_value())
                do_something_inside(temp.value());
        if(auto temp = outside.read())
            if(temp.has_value())
                do_something_outside(temp.value());
    }
}
#+END_SRC
~612 bytes~ of code size compiled with ~avr-gcc 10.2.0~ and ~-Os -mmcu=attiny85~.

** Temperature value with fractions
The policy ~WithDecimal~ enables the driver to handle the decimal part of a temperature value. The resolution of the device determines how the driver should read and store the fraction. Below, the example uses the default policy ~resolution::_12bits~, which means that type ~Decimal~ is equal to ~uint16_t~ and the fraction has a resolution of ~0.0625~.
#+BEGIN_SRC C++
template<typename Decimal>
void do_something(uint8_t whole, Decimal decimal){}

int main() {
    using namespace ds18b20;

    sensor<PB3, SkipRom, WithDecimal> thermo;

    while(true)
        if(auto temp = thermo.read()) {
            if(temp.has_value())
                do_something(temp.value(), temp.decimal());
        }
}
#+END_SRC
~580 bytes~ of code size compiled with ~avr-gcc 10.2.0~ and ~-Os -mmcu=attiny85~.

** Reading the Rom code
#+BEGIN_SRC C++
void do_something_with_each_byte(uint8_t b){
}

int main() {
    using thermo = ds18b20::sensor<PB3>;
    auto rom = thermo::rom();
    for(auto b : rom)
        do_something_with_each_byte(b);
}
#+END_SRC
~158 bytes~ of code size compiled with ~avr-gcc 10.2.0~ and ~-Os -mmcu=attiny85~.

** Features
1. Asynchronous(coroutine) and synchronous ways to read the temperature.
2. Support at compile-time to 9, 10, 11 e 12 bits of resolution.
3. Optional support at compile-time to handle temperature values with fractions.
4. Optional support at compile-time to allow the usage of the internal pullup resistor of the MCU I/O pin that represents the bus(DQ port).
5. Setup of the resolution as a one shot call that saves the configuration in the EEPROM.
6. Address of any device in the bus using the Skip Rom command.
7. Address of specifics devices in the bus using the Rom code.
8. Reading of the Rom code.
9. Support to multiple devices in the same bus(DQ port).

** Features that aren't supported
1. Negative temperatures
2. Search Rom
3. Alarm 
4. Parasite power mode

** Requirements
1. ~avr-gcc 10.2~ with support to C++20(~-std=c++20~)
2. ~avr-libc 2.0.0~
3. ~<type_traits>~ [If there isn't a freestanging implementation of ~libstdc++~, [[https://github.com/ricardocosme/type_traits][this subset of the header can be used.]]

** Usage
This is a header only library. The only thing that should be done is to include the header ~ds18b20.hpp~.

